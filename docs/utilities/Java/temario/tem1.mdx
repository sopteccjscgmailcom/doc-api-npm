# ğŸ“Œ Principios SOLID
---

Los principios **SOLID** son cinco reglas fundamentales para escribir cÃ³digo limpio, modular y mantenible en la **ProgramaciÃ³n Orientada a Objetos (POO)**. Fueron formulados por **Robert C. Martin** (*Uncle Bob*) y ayudan a reducir el acoplamiento y mejorar la reutilizaciÃ³n del cÃ³digo.  

---  

## ğŸ› ï¸ **S -  (SRP) (Principio de Responsabilidad Ãšnica)**  
ğŸ‘‰ **Single Responsibility Principle "Una clase debe tener una Ãºnica razÃ³n para cambiar."**  

Cada clase debe **tener una sola responsabilidad** dentro del sistema, evitando mezclar lÃ³gica de negocio con lÃ³gica de persistencia, interfaz de usuario, etc.  

ğŸ”´ **Problema sin SRP:**  
```java
class Employee {
    public void calculateSalary() { /* LÃ³gica de cÃ¡lculo de salario */ }
    public void saveToDatabase() { /* LÃ³gica para guardar en la BD */ }
}
```
- âŒ La clase `Employee` estÃ¡ manejando **dos responsabilidades**: lÃ³gica de negocio (cÃ¡lculo de salario) y persistencia (guardar en la base de datos).  
 
âœ… **SoluciÃ³n aplicando SRP:**  
```java
class Employee {
    public void calculateSalary() { /* LÃ³gica de salario */ }
}

class EmployeeRepository {
    public void saveToDatabase(Employee employee) { /* Guardar en BD */ }
}
```
- âœ… Ahora, `Employee` solo maneja la lÃ³gica de empleados y `EmployeeRepository` maneja la persistencia.  

---  

## ğŸ”“ **O - Open/Closed Principle (OCP) (Principio de Abierto/Cerrado)**  
ğŸ‘‰ **"El cÃ³digo debe estar abierto para extensiÃ³n, pero cerrado para modificaciÃ³n."**  

Debemos diseÃ±ar las clases de forma que puedan **ser extendidas sin modificar su cÃ³digo original**.  

ğŸ”´ **Problema sin OCP:**  
```java
class Shape {
    public double calculateArea(String shapeType, double value) {
        if (shapeType.equals("Circle")) {
            return Math.PI * value * value;
        } else if (shapeType.equals("Square")) {
            return value * value;
        }
        return 0;
    }
}
```
- âŒ Cada vez que agregamos una nueva figura, debemos modificar la clase `Shape`.  

âœ… **SoluciÃ³n aplicando OCP:**  
```java
interface Shape {
    double calculateArea();
}

class Circle implements Shape {
    private double radius;
    public Circle(double radius) { this.radius = radius; }
    @Override public double calculateArea() { return Math.PI * radius * radius; }
}

class Square implements Shape {
    private double side;
    public Square(double side) { this.side = side; }
    @Override public double calculateArea() { return side * side; }
}
```
- âœ… Ahora podemos agregar nuevas formas sin modificar el cÃ³digo original.  

---  

## ğŸ›ï¸ **L - Liskov Substitution Principle (LSP) (Principio de SustituciÃ³n de Liskov)**  
ğŸ‘‰ **"Las subclases deben poder ser usadas en lugar de sus clases base sin problemas."**  

Si una subclase rompe el comportamiento esperado de la clase base, estamos violando LSP.  

ğŸ”´ **Problema sin LSP:**  
```java
class Bird {
    public void fly() { System.out.println("Flying..."); }
}

class Penguin extends Bird {
    @Override
    public void fly() {
        throw new UnsupportedOperationException("Penguins can't fly");
    }
}
```
- âŒ Un `Penguin` es un `Bird`, pero **no puede volar**. Esto rompe el principio LSP.  

âœ… **SoluciÃ³n aplicando LSP:**  
```java
interface Bird { void eat(); }

interface FlyingBird extends Bird { void fly(); }

class Sparrow implements FlyingBird {
    @Override public void eat() { System.out.println("Eating..."); }
    @Override public void fly() { System.out.println("Flying..."); }
}

class Penguin implements Bird {
    @Override public void eat() { System.out.println("Eating..."); }
}
```
- âœ… Ahora `Penguin` **no tiene mÃ©todos que no necesita**, respetando LSP.  

---  

## ğŸ›‘ **I - Interface Segregation Principle (ISP) (Principio de SegregaciÃ³n de Interfaces)**  
ğŸ‘‰ **"No fuerces a una clase a implementar mÃ©todos que no usa."**  

ğŸ”´ **Problema sin ISP:**  
```java
interface Animal {
    void fly();
    void swim();
}

class Dog implements Animal {
    @Override
    public void fly() { throw new UnsupportedOperationException("Dogs can't fly"); }
    @Override
    public void swim() { System.out.println("Swimming..."); }
}
```
- âŒ `Dog` estÃ¡ obligado a implementar `fly()`, aunque no lo necesita.  

âœ… **SoluciÃ³n aplicando ISP:**  
```java
interface Swimmer { void swim(); }
interface Flyer { void fly(); }

class Dog implements Swimmer {
    @Override public void swim() { System.out.println("Swimming..."); }
}
```
- âœ… Ahora `Dog` **no tiene mÃ©todos innecesarios**.  

---  

## ğŸ”„ **D - Dependency Inversion Principle (DIP) (Principio de InversiÃ³n de Dependencias)**  
ğŸ‘‰ **"Las clases deben depender de abstracciones, no de implementaciones concretas."**  

ğŸ”´ **Problema sin DIP:**  
```java
class MySQLDatabase {
    public void connect() { System.out.println("Connecting to MySQL..."); }
}

class Application {
    private MySQLDatabase database = new MySQLDatabase();

    public void start() { database.connect(); }
}
```
- âŒ `Application` **depende directamente** de `MySQLDatabase`. Si queremos cambiar a PostgreSQL, debemos modificar la clase.  

âœ… **SoluciÃ³n aplicando DIP:**  
```java
interface Database { void connect(); }

class MySQLDatabase implements Database {
    @Override public void connect() { System.out.println("Connecting to MySQL..."); }
}

class PostgreSQLDatabase implements Database {
    @Override public void connect() { System.out.println("Connecting to PostgreSQL..."); }
}

class Application {
    private Database database;
    public Application(Database database) { this.database = database; }
    public void start() { database.connect(); }
}
```
- âœ… Ahora `Application` **depende de la abstracciÃ³n** (`Database`), y podemos usar cualquier base de datos sin modificar su cÃ³digo.  

---

## ğŸ¯ **Resumen rÃ¡pido de SOLID**  

| Principio | ExplicaciÃ³n | Beneficio |
|-----------|------------|-----------|
| **S** - Single Responsibility | Una clase debe tener una sola responsabilidad. | CÃ³digo mÃ¡s modular y fÃ¡cil de mantener. |
| **O** - Open/Closed | El cÃ³digo debe ser extensible sin modificarlo. | Facilita la escalabilidad y evita errores. |
| **L** - Liskov Substitution | Las subclases deben ser intercambiables con sus superclases. | Evita comportamientos inesperados. |
| **I** - Interface Segregation | No forzar a clases a implementar mÃ©todos que no usan. | Interfaces mÃ¡s especÃ­ficas y flexibles. |
| **D** - Dependency Inversion | Depender de abstracciones, no de implementaciones concretas. | Facilita pruebas y cambios de tecnologÃ­a. |

---

Ahora que ya tienes la teorÃ­a clara, Â¿quieres que te pase ejercicios para practicar? ğŸš€